<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"graph_theory_component_array_factory.js.html":{"id":"graph_theory_component_array_factory.js.html","title":"Source: graph_theory/component_array_factory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/component_array_factory.js var NodeArray = require('./node_array_factory'); var RobustArray = require('./robust_array_factory'); /** * Constructs a ComponentArray class given dependencies * @param {Function} NodeArray dependency * @param {Function} NodeClass dependency * @return {Function} The resulting ComponentArray class */ module.exports = function(NodeArray, NodeClass) { let Node = NodeClass; /** * represents a set of NodeArrays * @exports ComponentArray * @constructor * @memberOf! module:GraphTheory * @extends {RobustArray} */ class ComponentArray extends RobustArray.SetifyType(NodeArray) { /** * adds a component to the graph if not present * @param {Component} compArg */ push(compArg) { return this.integrateComponent(compArg) || super.push(compArg); } /** * checks if any components (excluding the argument) share nodes with the argument * @param {Component} compArg * @return {Boolean} */ hasIntersectingComponent(compArg) { return this.excludeElement(compArg).some(currComp =&gt; currComp.intersects(compArg)); } /** * returns the first component (excluding the argument) which intersect with compArg * @param {Component} compArg the component to be checked * @return {Component} the first intersecting component */ findIntersectingComponent(compArg) { return this.excludeElement(compArg).find(currComp =&gt; currComp.intersects(compArg)); } /** * combines the nodes of two intersecting components into orrgComp, and removes newComp * @param {Component} origComp the component taking precedence * @param {Component} newComp the component to be removed */ mergeComponents(origComp, newComp) { this.removeElement(newComp); return origComp.unionize(newComp); } /** * integrates a component into any of the arrays intersecting components * @param {Component} compArg */ integrateComponent(compArg) { let iComp = this.findIntersectingComponent(compArg); return (!!iComp) &amp;&amp; this.mergeComponents(iComp, compArg); } }; /** * [An Set of mutually exclusive NodeArrays]{@link module:GraphTheory.ComponentArray} * @typedef {module:GraphTheory.ComponentArray} ComponentArray */ return ComponentArray; }; × Search results Close "},"graph_theory_directed_edge.js.html":{"id":"graph_theory_directed_edge.js.html","title":"Source: graph_theory/directed_edge.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/directed_edge.js var Node = require('./node'); var NodeArray = require('./node_array_factory'); var Edge = require('./edge_factory'); /** * represents a connection between nodes * @exports DirectedEdge * @constructor * @memberOf! module:GraphTheory */ class DirectedEdge extends Edge { constructor(src = new Node(), dest = new Node(), weight = 0) { super(src, dest, weight); this.source = src; this.dest = dest; } isEquivalent(edgeArg) { return (edgeArg instanceof DirectedEdge) ? super.isEquivalent(edgeArg) : false; } } /** * [A DirectedEdge]{@link module:GraphTheory.DirectedEdge} * @typedef {module:GraphTheory.DirectedEdge} DirectedEdge */ module.exports = DirectedEdge; × Search results Close "},"graph_theory_edge_factory.js.html":{"id":"graph_theory_edge_factory.js.html","title":"Source: graph_theory/edge_factory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/edge_factory.js var Node = require('./node'); var NodeArray = require('./node_array_factory'); /** * Constructs [an Edge Class]{@link module:GraphTheory.EdgeArray} Class by dependencies * @memberOf! module:GraphTheory * @param {Function} NodeArray [The NodeArray Class]{@link module:GraphTheory.NodeArray} * @param {Function} NodeClass [The Node Class]{@link module:GraphTheory.Node} * @return {Function} [The resulting Edge Class]{@link module:GraphTheory.Edge} */ function EdgeFactory(NodeArray, NodeClass) { let Node = NodeClass; /** * represents a connection between nodes * @exports Edge * @constructor * @memberOf! module:GraphTheory */ class Edge { /** * creates an edge connecting two nodes * @param {Node} n1 * @param {Node} n2 * @param {Number} [weight=0] the value associated with the edge * @return {Edge} the new edge */ constructor(n1 = new Node(), n2 = new Node(), weight = 0) { /** * the weight of the edge * @type {Number} */ this.weight = weight; this.establishNodes(n1, n2); this.setLabel(); } establishNodes(n1, n2) { /** * an array of nodes * @type {NodeArray} */ this.nodes = NodeArray.of(n1, n2); } setLabel() { /** * an identifier for the Edge * @type {String} */ this.label = `${this.nodes[0].label}_${this.nodes[1].label}`; } /** * checks the equivalence (by nodes) of this edge against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ isEquivalent(edgeArg) { return this.hasSameNodes(edgeArg); } /** * checks the equivalence of this edge's label against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ hasSameName(edgeArg) { return (this.label) ? this.label === edgeArg.label : false; } /** * checks the equivalence of this edges nodes against another * @param {Edge} edgeArg edge to be checked * @return {Boolean} */ hasSameNodes(edgeArg) { return this.nodes.isEquivalent(edgeArg.nodes); } /** * Checks for the presence of a node in this edge * @param {Node} nodeArg * @return {Boolean} */ containsNode(nodeArg) { return this.nodes.contains(nodeArg); } /** * @param {Node} nodeArg * @return {Node} the neighbor */ getNeighbor(nodeArg) { return this.nodes.find(currNode =&gt; currNode != nodeArg); } /** * typecasts the neighboring node as a NodeArray with a single element (for method chaining) * @param {Node} nodeArg * @return {NodeArray} an Array of the neighboring node */ nabeArray(nodeArg) { return this.nodes.excludeElement(nodeArg); } } /** * [An Edge]{@link module:GraphTheory.Edge} * @typedef {module:GraphTheory.Edge} Edge */ return Edge; } /** * [An EdgeFactory]{@link module:GraphTheory.EdgeFactory} * @typedef {module:GraphTheory.EdgeFactory} EdgeFactory * @exports EdgeFactory */ module.exports = EdgeFactory; × Search results Close "},"graph_theory_edge_array_factory.js.html":{"id":"graph_theory_edge_array_factory.js.html","title":"Source: graph_theory/edge_array_factory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/edge_array_factory.js var Node = require('./node'); var NodeArray = require('./node_array_factory'); var Edge = require('./edge_factory'); // var DirectedEdge = require('./directedEdge'); var RobustArray = require('./robust_array_factory'); /** * Constructs [an EdgeArray]{@link module:GraphTheory.EdgeArray} Class by dependencies * @memberOf! module:GraphTheory * @param {Function} Edge [The Edge Class]{@link module:GraphTheory.Edge} * @param {Function} NodeArray [The NodeArray Class]{@link module:GraphTheory.NodeArray} * @param {Function} NodeClass [The Node Class]{@link module:GraphTheory.Node} * @return {Function} [The resulting EdgeArray class]{@link module:GraphTheory.EdgeArray} */ function EdgeArrayFactory(Edge, NodeArray, NodeClass) { let Node = NodeClass; /** * represents a set of Edges * @exports EdgeArray * @constructor * @memberOf! module:GraphTheory * @extends {RobustArray} */ class EdgeArray extends RobustArray.SetifyType(Edge) { /** * Filters the edges by those which contain the specified node * @param {Node} nArg the node in question * @return {EdgeArray} the filtered array */ edgesWithNode(nArg) { return this.filter(e =&gt; e.containsNode(nArg)); } /**/ edgeByNodes(n1, n2) { return this.find(e =&gt; (e.containsNode(n1) &amp;&amp; e.containsNode(n2))); } /** * * @param {NodeArray} nArr the nodes to be matched against * @return {EdgeArray} the edges intersecting nArr */ edgesByArray(nArr) { return nArr.reduce((eArr, nNode) =&gt; eArr.unionize(this.edgesWithNode(nNode)), new this.constructor()); } /** * @return {NodeArray} all of the nodes in this array of edges */ getNodes() { return this.nodeMap().reduce((pred, succ) =&gt; pred.unionize(succ), new NodeArray); } /** * @param {NodeArray} nArg the node to be matched against * @return {NodeArray} all of the nodes contained in this array */ getNeighbors(nArg) { let sharedEdges = this.edgesWithNode(nArg); return (!sharedEdges.isEmpty() &amp;&amp; sharedEdges.map(e =&gt; e.nabeArray(nArg)).reduce((pred, succ) =&gt; pred.unionize(succ))) || new NodeArray; } /** * @return {NodeArray[]} an array of all the nodes in this collection od edges */ nodeMap() { return ((!this.isEmpty()) &amp;&amp; this.map(e =&gt; e.nodes)) || new NodeArray; } } /** * [An EdgeArray]{@link module:GraphTheory.EdgeArray} * @typedef {module:GraphTheory.EdgeArray} EdgeArray */ return EdgeArray; } /** * [An EdgeArrayFactory]{@link module:GraphTheory.EdgeArrayFactory} * @typedef {module:GraphTheory.EdgeArrayFactory} EdgeArrayFactory * @exports EdgeArrayFactory */ module.exports = EdgeArrayFactory; × Search results Close "},"graph_theory_graph_factory.js.html":{"id":"graph_theory_graph_factory.js.html","title":"Source: graph_theory/graph_factory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/graph_factory.js var Node = require('./node'); var NodeArray = require('./node_array_factory'); var Edge = require('./edge_factory'); var EdgeArray = require('./edge_array_factory'); var ComponentArray = require('./component_array_factory'); /** * Constructs a Graph Class by dependencies * @memberOf! module:GraphTheory * @param {Function} EdgeArray [The EdgeArray Class]{@link module:GraphTheory.EdgeArray} * @param {Function} Edge [The Edge Class]{@link module:GraphTheory.Edge} * @param {Fucntion} ComponentArray [The ComponentArray Class]{@link module:GraphTheory.ComponentArray} * @param {Function} NodeArray [The NodeArray Class]{@link module:GraphTheory.NodeArray} * @param {Function} NodeClass [The Node Class]{@link module:GraphTheory.Node} * @return {Function} The resulting Graph class */ function GraphFactory(EdgeArray, Edge, ComponentArray, NodeArray, NodeClass) { let Node = NodeClass; /** * represents a Graph * @exports Graph * @constructor * @memberOf! module:GraphTheory */ class Graph { /** * creates a Graph object * @param {NodeArray} nodes the graph's nodes * @return {Graph} */ constructor(nodes) { this.establishNodes(nodes); this.establishEdges(); this.establishComponents(); } /** * assigns/typecasts the nodes attibute * @param {?NodeArray} nArr */ establishNodes(nArr) { /** * the graph's nodes * @type {NodeArray} */ this.nodes = nArr ? NodeArray.from(nArr) : new NodeArray; } /** * assigns/typecasts the edges attibute */ establishEdges() { /** * the graph's edges * @type {EdgeArray} */ this.edges = new EdgeArray; } /** * assigns/typecasts the components attibute */ establishComponents() { /** * the graph's components * @type {ComponentArray} */ this.components = new ComponentArray(); } /** * @see [delegated to NodeArray#push] {@link module:GraphTheory.NodeArray#push} */ addNode(node) { this.nodes.push(node); return this; } /** * @see [delegated NodeArray#contains] {@link module:GraphTheory.NodeArray#contains} */ containsNode(argNode) { return this.nodes.contains(argNode); } /** * removes all edges associated with the argument, then calls removes the node * @see [delegated NodeArray#push] {@link module:GraphTheory.NodeArray#removeElement} * @see [remove edge] {@link module:GraphTheory.Graph#removeEdge} */ removeNode(nodeArg) { this.edgesWithNode(nodeArg).forEach(e =&gt; this.removeEdge(e)); this.nodes.removeElement(nodeArg); return this; } /** * removes all edges associated with the argument, then removes all nodes the node * @see [delegated NodeArray#push] {@link module:GraphTheory.NodeArray#clear} * @see [remove edge] {@link module:GraphTheory.Graph#removeEdge} * @return {Graph} the current graph */ clearNodes() { this.nodes.forEach(n =&gt; this.removeNode(n)); this.nodes.clear(); return this; } /** * clears the nodes and reassigns them to narr * @param {NodeArray} nArr * @return {Graph} the current graph */ setNodes(nArr) { this.clearNodes(); this.nodes = nArr; return this; } /** * merges the nodes from the argument into the current graphs nodes * @param {NodeArray} nArr nodes to merge * @return {Graph} the current graph */ copyNodes(nArr) { this.nodes.unionize(nArr); return this; } /** * @param {Node} nodeArg source node * @return {EdgeArray} the edges connected to source */ edgesWithNode(nodeArg) { return this.edges.edgesWithNode(nodeArg); } /** * creates a new edge given two nodes * @param {Node} sNode source node * @param {Node} dNode destination node * @param {Number} weight weight of new edge * @return {Edge} the newly added edge */ createEdge(sNode, dNode, weight) { this.addEdge(new Edge(sNode, dNode, weight)); return this.edges.edgeByNodes(sNode, dNode); } /** * copies the nodes from the edge, then adds it to the edges array * @param {Edge} edgeArg * @see [delegated NodeArray#push] {@link module:GraphTheory.NodeArray#removeElement} * @return {Graph} the current graph */ addEdge(edgeArg) { this.copyNodes(edgeArg.nodes); this.edges.push(edgeArg); return this; } /** * @see [delegated to EdgeArray#push] {@link module:GraphTheory.EdgeArray#push} */ containsEdge(argEdge) { return this.edges.contains(argEdge); } /** * @see [delegated to EdgeArray#removeElement] {@link module:GraphTheory.EdgeArray#removeElement} */ removeEdge(argEdge) { this.edges.removeElement(argEdge); } /** * @see [delegated to EdgeArray#clear] {@link module:GraphTheory.EdgeArray#clear} * @return {Graph} the current graph */ clearEdges() { this.edges.clear(); return this; } /** * clears and reassigns nodes to those of the edge array, and sets the edges * functions basically as a graph reset, an easy way to explore a graph from different angles * @see [calls EdgeArray#getNodes] {@link module:GraphTheory.EdgeArray#getNodes} * @param {EdgeArray} eArr * @return {Graph} the modified graph */ setEdges(eArr) { let eNodes = eArr.getNodes(); this.setNodes(eNodes); this.edges = eArr; return this; } /** * copies and merges the nodes from the edgeArray, then merges the edges into the current graph * @param {EdgeArray} eArr * @return {Graph} the modified graph */ copyEdges(eArr) { let eNodes = eArr.getNodes(); this.copyNodes(eNodes); this.edges.unionize(eArr); return this; } /** * creates a new graph * @param {?NodeArray} nArr a potential inital set of Nodes * @return {Graph} a new Graph instance */ subGraph(nArr) { return new this.constructor(nArr); } /** * creates a new graph, and sets its edges, * useful for exploring a graph based on different connections * @param {EdgeArray} [eArr = this.edges] a potential inital set of Edges * @return {Graph} a new Graph instance */ subGraphByEdges(eArr = this.edges) { return this.subGraph().copyEdges(eArr); } /** * * @param {Node} nodeArg the source node * @return {NodeArray} the neighboring nodes */ getNeighbors(nodeArg) { return this.edges.getNeighbors(nodeArg); } /** * typecasts a path to a NodeArray * @param {Map} pathArg an ordered sequence of nodes with predecessors and path weights * @return {NodeArray} An array of the nodes */ pathNodes(pathArg) { return NodeArray.from([...pathArg.keys()]); } /** * returns all of the Edges connected to a node whose neighbors have yet to be visited * @param {Node} nodeArg the node * @param {NodeArray} compArg the component being explored * @return {EdgeArray} the edges with unexplored nodes */ getUnvisitedEdges(nodeArg, compArg) { let unArr = this.getUnvisitedNeighbors(nodeArg, compArg); return this.edgesWithNode(nodeArg).edgesByArray(unArr); } /** * returns all of the nodes neighbors not yet part explored in the component * @param {Node} nodeArg * @param {NodeArray} compArg the explored component * @return {NodeArray} unexplored nodes */ getUnvisitedNeighbors(nodeArg, compArg) { return this.getNeighbors(nodeArg).difference(compArg); } /** * adds all unvisited nodes in the path to the specified component * @param {Map} pathArg the path to be explored */ visitPath(pathArg) { let pNodes = this.pathNodes(pathArg); let lastNode = pNodes.pop(); let nextEdges = this.getUnvisitedEdges(lastNode, pNodes); if (nextEdges.length === 0) { return pathArg; } else { let predWeight = pathArg.get(lastNode).pathWeight; let predCount = pathArg.get(lastNode).edgeCount; nextEdges.forEach(currEdge =&gt; { let nabe = currEdge.getNeighbor(lastNode); pathArg.set(nabe, { pred: lastNode, edgeCount: predCount + 1, pathWeight: predWeight + currEdge.weight }); this.visitPath(pathArg); }); } return pathArg; } /** * depth first search, initializes a new component of reachable nodes, * and constructs a path to each of those node from the initNode * @param {Node} initNode the source node * @return {Map} a key-value store of nodes and edge distances */ dfs(initNode) { let path = new Map(); path.set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); this.visitPath(path); let pComp = this.pathNodes(path); this.addComponent(pComp); return path; } containsComponent(compArg) { return this.components.contains(compArg); } /** * adds a component to the graph if not present * @param {NodeArray} compArg */ addComponent(compArg) { this.components.push(compArg); } removeComponent(compArg) { this.components.removeElement(compArg); } /** * returns any current components which intersect with the specified component * @param {NodeArray} compArg the component to be checked * @return {NodeArray} the first intersecting component */ findIntersectingComponent(compArg) { return this.components.findIntersectingComponent(compArg); } /** * combines the nodes of two intersecting components * @param {NodeArray} origComp * @param {NodeArray} newComp */ mergeComponents(origComp, newComp) { return this.components.mergeComponents(origComp, newComp); } /** * integrates a component into any of the graphs intersectung components * @param {NodeArray} compArg */ integrateComponent(compArg) { return this.components.integrateComponent(compArg); } /** * checks if any current components share nodes with the argument * @param {NodeArray} compArg * @return {Boolean} */ hasIntersectingComponent(compArg) { return this.components.some(currComp =&gt; currComp.intersects(compArg)); } /** * breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node * @param {Node} initNode inital node * @return {Map} a key-value store of nodes and edge distances */ bfs(initNode = this.nodes[0]) { var bPath = new Map().set(initNode, { pred: null, pathWeight: 0, edgeCount: 0 }); var bQueue = NodeArray.of(initNode); while (bQueue.length &gt; 0) { let currN = bQueue.shift(); var bNodes = this.pathNodes(bPath); let currEdges = this.getUnvisitedEdges(currN, bNodes); let prNode = bPath.get(currN); currEdges.forEach((nEdge) =&gt; { let nNode = nEdge.getNeighbor(currN); bPath.set(nNode, { pred: currN, edgeCount: prNode.edgeCount + 1, pathWeight: prNode.pathWeight + nEdge.weight }); bQueue.push(nNode); }); } this.addComponent(bNodes); return bPath; } /** * check if a path exists between two nodes * @param {Node} initNode the initial node * @param {Node} termNode the terminal node * @return {Boolean} does a path exist between the two nodes */ hasPath(initNode, termNode) { return this.bfs(initNode).has(termNode); } /** * performs dijkstras algorithm for shortest paths to all nodes reachable from initNode * @param {Node} initNode the initial node * @return {Map} a sequence of nodes and their distances */ dijkstra(initNode = this.nodes[0]) { var reachables = this.bfs(initNode); var inspectionQueue = NodeArray.of(initNode); var solutionSet = new Map().set(initNode, { pred: null, edgeCount: 0, pathWeight: 0 }); while (inspectionQueue.length &gt; 0) { var currN = inspectionQueue.shift(); var currEdges = this.edgesWithNode(currN); currEdges.forEach((tempEdge) =&gt; { let nNode = tempEdge.getNeighbor(currN); var rNodeEntry = reachables.get(nNode); var currWeight = rNodeEntry.pathWeight; var sPred = solutionSet.get(currN); var dijkstraWeight = sPred.pathWeight + tempEdge.weight; let dMap = { pred: currN, edgeCount: sPred.edgeCount + 1, pathWeight: dijkstraWeight }; let sMap = (dijkstraWeight &lt; currWeight) ? dMap : rNodeEntry; if (!solutionSet.has(nNode)) { inspectionQueue.push(nNode); solutionSet.set(nNode, sMap); } }); } return solutionSet; } /** * composes the shortest path between two nodes by backtracing from dijkstra * @param {Node} initNode * @param {Node} termNode * @return {?Map} path of nodes */ shortestPath(initNode, termNode) { if (!this.hasPath(initNode, termNode)) { return false; } else { let dijkMap = this.dijkstra(initNode); let currN = termNode; let currEntry = dijkMap.get(currN); let predN = currEntry.pred; let path = new Map(); while (currN != initNode) { path.set(currN, currEntry); currN = predN; currEntry = dijkMap.get(currN); predN = currEntry.pred; } return path; } } }; /** * [A Graph]{@link module:GraphTheory.Graph} * @typedef {module:GraphTheory.Graph} Graph */ return Graph; } /** * [A GraphFactory]{@link module:GraphTheory.GraphFactory} * @typedef {module:GraphTheory.GraphFactory} GraphFactory * @exports GraphFactory */ module.exports = GraphFactory; × Search results Close "},"graph_theory_dependency_injector.js.html":{"id":"graph_theory_dependency_injector.js.html","title":"Source: graph_theory/dependency_injector.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/dependency_injector.js var argsList = require('args-list'); /** * [An Injector]{@link module:GraphTheory.Injector} * @typedef {module:GraphTheory.Injector} Injector */ /** * * @return {Injector} a container managing dependencies for each of the classes */ module.exports = function Injector() { /** * a key value store of all classes * @type {Object} */ var dependencies = {}; /** * the facotries creating each type * @type {Object} */ var factories = {}; /** * the containter object that will build the dependency tree * @type {Object} */ var container = {}; /** * sets the factory module given name * @param {String} name the name of the factory producing the class * @param {Function} fMod the function/module that produces the class */ container.factory = function setFactory(name, fMod) { factories[name] = fMod; }; /** * registers a dependency with a module * @param {Stinrg} name the name of the dependency * @param {Fucntion} dep the source file/function of the dependency */ container.register = function register(name, dep) { dependencies[name] = dep; } /** * calls the factory method on the specified module and retrieves all depenencues before returning the requested class * @param {Sting} name The name of the class to be returned * @return {Function} the class requested */ container.retrieve = function retrieve(name) { if (!dependencies[name]) { let factory = factories[name]; dependencies[name] = factory &amp;&amp; container.inject(factory); if (!dependencies[name]) { throw new Error('Cannot find module: ' + name); } } return dependencies[name]; } /** * injects the dependencies of each module via calling it's method * @param {Function} factory The class creating factory * @return {Function} the class requested */ container.inject = function inject(factory) { let fArgs = argsList(factory).map(depArg =&gt; container.retrieve(depArg)); return factory.apply(null, fArgs); }; return container; }; × Search results Close "},"graph_theory.js.html":{"id":"graph_theory.js.html","title":"Source: graph_theory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory.js /** * @module GraphTheory */ var Injector = require('./graph_theory/dependency_injector')(); var Node = require('./graph_theory/node'); var RobustArray = require('./graph_theory/robust_array_factory'); var NodeArray = require('./graph_theory/node_array_factory'); var DirectedEdge = require('./graph_theory/directed_edge'); var Edge = require('./graph_theory/edge_factory'); var EdgeArray = require('./graph_theory/edge_array_factory'); var ComponentArray = require('./graph_theory/component_array_factory'); var Graph = require('./graph_theory/graph_factory'); Injector.register('NodeClass', Node); Injector.register('RobustArray', RobustArray); Injector.factory('NodeArray', NodeArray); Injector.factory('ComponentArray', ComponentArray); Injector.factory('Edge', Edge); Injector.factory('EdgeArray', EdgeArray); Injector.factory('Graph', Graph); Injector.retrieve('Graph'); exports.Node = Injector.retrieve(&quot;NodeClass&quot;); exports.NodeArray = Injector.retrieve('NodeArray'); exports.RobustArray = Injector.retrieve(&quot;RobustArray&quot;); exports.NodeArray = Injector.retrieve(&quot;NodeArray&quot;); exports.Edge = Injector.retrieve(&quot;Edge&quot;); exports.EdgeArray = Injector.retrieve(&quot;EdgeArray&quot;); exports.ComponentArray = Injector.retrieve(&quot;ComponentArray&quot;); exports.Graph = Injector.retrieve(&quot;Graph&quot;); × Search results Close "},"graph_theory_node.js.html":{"id":"graph_theory_node.js.html","title":"Source: graph_theory/node.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/node.js /** * represent a Node * @exports Node * @constructor * @memberOf module:GraphTheory * @param {String} label [label property]{@link module:GraphTheory.Node#label} * @param {Object} data the nodes data */ class Node { constructor(label, data) { this.setLabel(label); this.setData(data); } /** * sets the node's label attribute * @param {String} lbl */ setLabel(lbl) { /** * the node identifier * @type {String} */ return this.label = lbl; } /** * sets the node's data attribute * @param {Object} d */ setData(d) { /** * the node data * @type {Object} */ return this.data = d || {}; } /** * Checks for identity via label attribute * @param {Node} newNode the node to be compared * @return {Boolean} */ isEquivalent(newNode) { return this.label === newNode.label; } } /** * [A Node]{@link module:GraphTheory.Node} * @typedef {module:GraphTheory.Node} Node */ module.exports = Node; × Search results Close "},"graph_theory_node_array_factory.js.html":{"id":"graph_theory_node_array_factory.js.html","title":"Source: graph_theory/node_array_factory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/node_array_factory.js var Node = require('./node'); var RobustArray = require('./robust_array_factory'); /** * Constructs [A NodeArray Class]{@link module:GraphTheory.NodeArray} by dependencies * @memberOf! module:GraphTheory * @param {Function} NodeClass [The Node Class]{@link module:GraphTheory.Node} * @return {Function} [The resulting NodeArray Class]{@link module:GraphTheory.NodeArray} */ function NodeArrayFactory(NodeClass) { let Node = NodeClass; /** * represents a set of Nodes * @exports NodeArray * @constructor * @extends {RobustArray} * @memberOf! module:GraphTheory */ class NodeArray extends RobustArray.SetifyType(Node) {} /** * [A NodeArray]{@link module:GraphTheory.NodeArray} * @typedef {module:GraphTheory.NodeArray} NodeArray */ return NodeArray; } /** * [An NodeArrayFactory]{@link module:GraphTheory.NodeArrayFactory} * @typedef {module:GraphTheory.NodeArrayFactory} NodeArrayFactory * @exports NodeArrayFactory */ module.exports = NodeArrayFactory; × Search results Close "},"graph_theory_robust_array_factory.js.html":{"id":"graph_theory_robust_array_factory.js.html","title":"Source: graph_theory/robust_array_factory.js","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Source: graph_theory/robust_array_factory.js /** * Constructs [An Array Subclass]{@link module:GraphTheory.RobustArray} * @memberOf! module:GraphTheory * @param {Function} BaseType the data type/Class of objects stored in this array * @return {Function} [The resulting RobustArray Class]{@link module:GraphTheory.RobustArray} */ function RobustArrayFactory(BaseType) { /** * a type-specific array class implementing set theory * @exports RobustArray * @constructor * @memberOf! module:GraphTheory * @extends Array */ let RobustArray = class extends Array { /** * @memberof! module:GraphTheory.RobustArray# * @inner * checks the data type of the new element * @param {Object} argObj * @return {Boolean} */ isValid(argObj) { return argObj instanceof BaseType; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @return {Boolean} is the array length 0 */ isEmpty() { return this.length === 0; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * checks for presence of an element in this set * @param {Object} argObj * @return {Boolean} */ contains(argObj) { return this.some(el =&gt; el.isEquivalent(argObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * appends an element to this array if passes the type validator and is not already present * @param {Object} argObj * @return {RobustArray} the current array */ push(argObj) { if ((this.isValid(argObj) &amp;&amp; !(this.contains(argObj)))) { super.push(argObj); } return this; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#filter * @param {...Object} args JS Native Array#filter arguments * @return {RobustArray} */ filter(...args) { return this.constructor.from(super.filter(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#slice * @param {...Object} args JS Native Array#slice arguments * @return {RobustArray} */ slice(...args) { return this.constructor.from(super.slice(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#concat * @param {...Object} args JS Native Array#concat arguments * @return {RobustArray} */ concat(...args) { return this.constructor.from(super.concat(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * coerces return type to a RobustArray after delegating to Native Array#splice * @param {...Object} args JS Native Array#splice arguments * @return {RobustArray} */ splice(...args) { return this.constructor.from(super.splice(...args)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {RobustArray} altArray * @return {Boolean} do the arrays have the same length */ hasSameSize(altArray) { return this.length === altArray.length; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {Object} altArray * @return {Boolean} does the altArray contain every element of the receiver */ isSubset(altArray) { return this.every(myObj =&gt; altArray.contains(myObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {Object} altArray * @return {Boolean} do the argument nad receiver share length and elements */ isEquivalent(altArray) { return (this.hasSameSize(altArray) &amp;&amp; this.isSubset(altArray)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns the first element which is equivalent to the argument * @param {Object} altArray * @return {?Object} */ findEquivalentElement(argObj) { return this.find(el =&gt; el.isEquivalent(argObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * removes the argument from the array * @param {Object} argObj * @return {(Object|Boolean)} */ removeElement(argObj) { let eqIdx = this.findIndex(el =&gt; el.isEquivalent(argObj)); return eqIdx &gt; -1 &amp;&amp; this.splice(eqIdx, 1); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * removes all elements from the array * @param {Object} altArray * @return {RobustArray} the newly empty array */ clear() { this.splice(0); return this; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @return {RobustArray} a copy of this array */ copy() { return this.slice(0); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * checks for presence of shared elements between two sets * @param {RobustArray} altArray the array to check * @return {Boolean} */ intersects(altArray) { return this.some(currEl =&gt; altArray.contains(currEl) === true); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns an array shared elements between two sets * @param {RobustArray} altArray the array to check * @return {RobustArray} the shared elements */ intersection(altArray) { return this.filter(currEl =&gt; altArray.contains(currEl) === true); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @param {RobustArray} altArray the array to check * @return {Boolean} does the caller have any element not included in the argument */ hasDistinctElements(altArray) { return this.some(myObj =&gt; !altArray.contains(myObj)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns an array elements in this array not included in the alternate array * @param {RobustArray} altArray the array to check * @return {RobustArray} the unshared elements */ difference(altArray) { return this.filter(n =&gt; !altArray.contains(n)); } /** * @memberof! module:GraphTheory.RobustArray# * @inner * returns a combined array of elements contained in the receiver or altArray * @param {RobustArray} altArray * @return {RobustArray} */ union(altArray) { let uArray = new this.constructor(); this.forEach(currEl =&gt; uArray.push(currEl)); altArray.forEach(altElem =&gt; uArray.push(altElem)); return uArray; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * combines all the elements from altArray into the receiver * @param {RobustArray} altArray * @return {RobustArray} the receiver */ unionize(altArray) { altArray.difference(this).forEach(dNode =&gt; this.push(dNode)); return this; } /** * @memberof! module:GraphTheory.RobustArray# * @inner * @memberof! module:GraphTheory.RobustArray * @param {Object} exElem the element to exclude * @return {RobustArray} all of the elements in this object excluding exElem */ excludeElement(exElem) { return this.filter(el =&gt; el != exElem); } }; /** * [A RobustArray]{@link module:GraphTheory.RobustArray} * @typedef {module:GraphTheory.RobustArray} RobustArray */ return RobustArray; } /** * [A RobustArrayFactory]{@link module:GraphTheory.RobustArrayFactory} * @typedef {module:GraphTheory.RobustArrayFactory} RobustArrayFactory * @exports RobustArray */ module.exports.SetifyType = RobustArrayFactory; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Global Type Definitions ComponentArray An Set of mutually exclusive NodeArrays Type: module:GraphTheory.ComponentArray Source: graph_theory/component_array_factory.js, line 61 DirectedEdge A DirectedEdge Type: module:GraphTheory.DirectedEdge Source: graph_theory/directed_edge.js, line 22 Edge An Edge Type: module:GraphTheory.Edge Source: graph_theory/edge_factory.js, line 102 EdgeArray An EdgeArray Type: module:GraphTheory.EdgeArray Source: graph_theory/edge_array_factory.js, line 69 Graph A Graph Type: module:GraphTheory.Graph Source: graph_theory/graph_factory.js, line 435 Injector An Injector Type: module:GraphTheory.Injector Source: graph_theory/dependency_injector.js, line 2 Node A Node Type: module:GraphTheory.Node Source: graph_theory/node.js, line 46 NodeArray A NodeArray Type: module:GraphTheory.NodeArray Source: graph_theory/node_array_factory.js, line 21 RobustArray A RobustArray Type: module:GraphTheory.RobustArray Source: graph_theory/robust_array_factory.js, line 240 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Modules Classes ComponentArray DirectedEdge Edge EdgeArray Graph Node NodeArray RobustArray × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Classes Classes ComponentArray DirectedEdge Edge EdgeArray Graph Node NodeArray RobustArray × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global × Search results Close "},"module-EdgeArrayFactory.html":{"id":"module-EdgeArrayFactory.html","title":"Module: EdgeArrayFactory","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: EdgeArrayFactory An EdgeArrayFactory Source: graph_theory/edge_array_factory.js, line 75 × Search results Close "},"module-EdgeFactory.html":{"id":"module-EdgeFactory.html","title":"Module: EdgeFactory","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: EdgeFactory An EdgeFactory Source: graph_theory/edge_factory.js, line 108 × Search results Close "},"module-GraphFactory.html":{"id":"module-GraphFactory.html","title":"Module: GraphFactory","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: GraphFactory A GraphFactory Source: graph_theory/graph_factory.js, line 442 × Search results Close "},"module-GraphTheory.html":{"id":"module-GraphTheory.html","title":"Module: GraphTheory","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: GraphTheory Source: graph_theory.js, line 1 Classes ComponentArray DirectedEdge Edge EdgeArray Graph Node NodeArray RobustArray Methods &lt;static&gt; EdgeArrayFactory(Edge, NodeArray, NodeClass) Constructs an EdgeArray Class by dependencies Parameters: Name Type Description Edge function The Edge Class NodeArray function The NodeArray Class NodeClass function The Node Class Source: graph_theory/edge_array_factory.js, line 16 Returns: The resulting EdgeArray class Type function &lt;static&gt; EdgeFactory(NodeArray, NodeClass) Constructs an Edge Class Class by dependencies Parameters: Name Type Description NodeArray function The NodeArray Class NodeClass function The Node Class Source: graph_theory/edge_factory.js, line 11 Returns: The resulting Edge Class Type function &lt;static&gt; GraphFactory(EdgeArray, Edge, ComponentArray, NodeArray, NodeClass) Constructs a Graph Class by dependencies Parameters: Name Type Description EdgeArray function The EdgeArray Class Edge function The Edge Class ComponentArray Fucntion The ComponentArray Class NodeArray function The NodeArray Class NodeClass function The Node Class Source: graph_theory/graph_factory.js, line 17 Returns: The resulting Graph class Type function &lt;static&gt; NodeArrayFactory(NodeClass) Constructs A NodeArray Class by dependencies Parameters: Name Type Description NodeClass function The Node Class Source: graph_theory/node_array_factory.js, line 10 Returns: The resulting NodeArray Class Type function &lt;static&gt; RobustArrayFactory(BaseType) Constructs An Array Subclass Parameters: Name Type Description BaseType function the data type/Class of objects stored in this array Source: graph_theory/robust_array_factory.js, line 7 Returns: The resulting RobustArray Class Type function × Search results Close "},"module-GraphTheory.ComponentArray.html":{"id":"module-GraphTheory.ComponentArray.html","title":"Class: ComponentArray","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: ComponentArray GraphTheory. ComponentArray represents a set of NodeArrays new ComponentArray() Source: graph_theory/component_array_factory.js, line 18 Extends RobustArray Methods findIntersectingComponent(compArg) returns the first component (excluding the argument) which intersect with compArg Parameters: Name Type Description compArg Component the component to be checked Source: graph_theory/component_array_factory.js, line 39 Returns: the first intersecting component Type Component hasIntersectingComponent(compArg) checks if any components (excluding the argument) share nodes with the argument Parameters: Name Type Description compArg Component Source: graph_theory/component_array_factory.js, line 31 Returns: Type Boolean integrateComponent(compArg) integrates a component into any of the arrays intersecting components Parameters: Name Type Description compArg Component Source: graph_theory/component_array_factory.js, line 55 mergeComponents(origComp, newComp) combines the nodes of two intersecting components into orrgComp, and removes newComp Parameters: Name Type Description origComp Component the component taking precedence newComp Component the component to be removed Source: graph_theory/component_array_factory.js, line 47 push(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg Component Source: graph_theory/component_array_factory.js, line 23 × Search results Close "},"module-GraphTheory.DirectedEdge.html":{"id":"module-GraphTheory.DirectedEdge.html","title":"Class: DirectedEdge","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: DirectedEdge GraphTheory. DirectedEdge represents a connection between nodes new DirectedEdge() Source: graph_theory/directed_edge.js, line 11 × Search results Close "},"module-GraphTheory.Edge.html":{"id":"module-GraphTheory.Edge.html","title":"Class: Edge","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: Edge GraphTheory. Edge represents a connection between nodes new Edge(n1, n2 [, weight]) creates an edge connecting two nodes Parameters: Name Type Argument Default Description n1 Node n2 Node weight Number &lt;optional&gt; 0 the value associated with the edge Source: graph_theory/edge_factory.js, line 19 × Search results Close "},"module-GraphTheory.EdgeArray.html":{"id":"module-GraphTheory.EdgeArray.html","title":"Class: EdgeArray","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: EdgeArray GraphTheory. EdgeArray represents a set of Edges new EdgeArray() Source: graph_theory/edge_array_factory.js, line 26 Extends RobustArray Methods edgesByArray(nArr) Parameters: Name Type Description nArr NodeArray the nodes to be matched against Source: graph_theory/edge_array_factory.js, line 44 Returns: the edges intersecting nArr Type EdgeArray edgesWithNode(nArg) Filters the edges by those which contain the specified node Parameters: Name Type Description nArg Node the node in question Source: graph_theory/edge_array_factory.js, line 32 Returns: the filtered array Type EdgeArray getNeighbors(nArg) Parameters: Name Type Description nArg NodeArray the node to be matched against Source: graph_theory/edge_array_factory.js, line 57 Returns: all of the nodes contained in this array Type NodeArray getNodes() Source: graph_theory/edge_array_factory.js, line 50 Returns: all of the nodes in this array of edges Type NodeArray nodeMap() Source: graph_theory/edge_array_factory.js, line 64 Returns: an array of all the nodes in this collection od edges Type Array.&lt;NodeArray&gt; × Search results Close "},"module-GraphTheory.Graph.html":{"id":"module-GraphTheory.Graph.html","title":"Class: Graph","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: Graph GraphTheory. Graph represents a Graph new Graph(nodes) creates a Graph object Parameters: Name Type Description nodes NodeArray the graph's nodes Source: graph_theory/graph_factory.js, line 25 Members components :ComponentArray the graph's components Type: ComponentArray Source: graph_theory/graph_factory.js, line 65 edges :EdgeArray the graph's edges Type: EdgeArray Source: graph_theory/graph_factory.js, line 55 nodes :NodeArray the graph's nodes Type: NodeArray Source: graph_theory/graph_factory.js, line 45 Methods addComponent(compArg) adds a component to the graph if not present Parameters: Name Type Description compArg NodeArray Source: graph_theory/graph_factory.js, line 297 addEdge(edgeArg) copies the nodes from the edge, then adds it to the edges array Parameters: Name Type Description edgeArg Edge Source: graph_theory/graph_factory.js, line 144 See: [delegated NodeArray#push] module:GraphTheory.NodeArray#removeElement Returns: the current graph Type Graph addNode() Source: graph_theory/graph_factory.js, line 70 See: [delegated to NodeArray#push] module:GraphTheory.NodeArray#push bfs(initNode) breadth first search, recursively adds all immediate neighbors, to a component of nodes reachabe by a initial node Parameters: Name Type Description initNode Node inital node Source: graph_theory/graph_factory.js, line 339 Returns: a key-value store of nodes and edge distances Type Map clearEdges() Source: graph_theory/graph_factory.js, line 165 See: [delegated to EdgeArray#clear] module:GraphTheory.EdgeArray#clear Returns: the current graph Type Graph clearNodes() removes all edges associated with the argument, then removes all nodes the node Source: graph_theory/graph_factory.js, line 96 See: [delegated NodeArray#push] module:GraphTheory.NodeArray#clear [remove edge] module:GraphTheory.Graph#removeEdge Returns: the current graph Type Graph containsEdge() Source: graph_theory/graph_factory.js, line 152 See: [delegated to EdgeArray#push] module:GraphTheory.EdgeArray#push containsNode() Source: graph_theory/graph_factory.js, line 77 See: [delegated NodeArray#contains] module:GraphTheory.NodeArray#contains copyEdges(eArr) copies and merges the nodes from the edgeArray, then merges the edges into the current graph Parameters: Name Type Description eArr EdgeArray Source: graph_theory/graph_factory.js, line 187 Returns: the modified graph Type Graph copyNodes(nArr) merges the nodes from the argument into the current graphs nodes Parameters: Name Type Description nArr NodeArray nodes to merge Source: graph_theory/graph_factory.js, line 116 Returns: the current graph Type Graph createEdge(sNode, dNode, weight) creates a new edge given two nodes Parameters: Name Type Description sNode Node source node dNode Node destination node weight Number weight of new edge Source: graph_theory/graph_factory.js, line 134 Returns: the newly added edge Type Edge dfs(initNode) depth first search, initializes a new component of reachable nodes, and constructs a path to each of those node from the initNode Parameters: Name Type Description initNode Node the source node Source: graph_theory/graph_factory.js, line 277 Returns: a key-value store of nodes and edge distances Type Map dijkstra(initNode) performs dijkstras algorithm for shortest paths to all nodes reachable from initNode Parameters: Name Type Description initNode Node the initial node Source: graph_theory/graph_factory.js, line 378 Returns: a sequence of nodes and their distances Type Map edgesWithNode(nodeArg) Parameters: Name Type Description nodeArg Node source node Source: graph_theory/graph_factory.js, line 124 Returns: the edges connected to source Type EdgeArray establishComponents() assigns/typecasts the components attibute Source: graph_theory/graph_factory.js, line 60 establishEdges() assigns/typecasts the edges attibute Source: graph_theory/graph_factory.js, line 50 establishNodes(nArr) assigns/typecasts the nodes attibute Parameters: Name Type Argument Description nArr NodeArray &lt;nullable&gt; Source: graph_theory/graph_factory.js, line 40 findIntersectingComponent(compArg) returns any current components which intersect with the specified component Parameters: Name Type Description compArg NodeArray the component to be checked Source: graph_theory/graph_factory.js, line 308 Returns: the first intersecting component Type NodeArray getNeighbors(nodeArg) Parameters: Name Type Description nodeArg Node the source node Source: graph_theory/graph_factory.js, line 215 Returns: the neighboring nodes Type NodeArray getUnvisitedEdges(nodeArg, compArg) returns all of the Edges connected to a node whose neighbors have yet to be visited Parameters: Name Type Description nodeArg Node the node compArg NodeArray the component being explored Source: graph_theory/graph_factory.js, line 232 Returns: the edges with unexplored nodes Type EdgeArray getUnvisitedNeighbors(nodeArg, compArg) returns all of the nodes neighbors not yet part explored in the component Parameters: Name Type Description nodeArg Node compArg NodeArray the explored component Source: graph_theory/graph_factory.js, line 242 Returns: unexplored nodes Type NodeArray hasIntersectingComponent(compArg) checks if any current components share nodes with the argument Parameters: Name Type Description compArg NodeArray Source: graph_theory/graph_factory.js, line 331 Returns: Type Boolean hasPath(initNode, termNode) check if a path exists between two nodes Parameters: Name Type Description initNode Node the initial node termNode Node the terminal node Source: graph_theory/graph_factory.js, line 370 Returns: does a path exist between the two nodes Type Boolean integrateComponent(compArg) integrates a component into any of the graphs intersectung components Parameters: Name Type Description compArg NodeArray Source: graph_theory/graph_factory.js, line 323 mergeComponents(origComp, newComp) combines the nodes of two intersecting components Parameters: Name Type Description origComp NodeArray newComp NodeArray Source: graph_theory/graph_factory.js, line 316 pathNodes(pathArg) typecasts a path to a NodeArray Parameters: Name Type Description pathArg Map an ordered sequence of nodes with predecessors and path weights Source: graph_theory/graph_factory.js, line 223 Returns: An array of the nodes Type NodeArray removeEdge() Source: graph_theory/graph_factory.js, line 158 See: [delegated to EdgeArray#removeElement] module:GraphTheory.EdgeArray#removeElement removeNode() removes all edges associated with the argument, then calls removes the node Source: graph_theory/graph_factory.js, line 85 See: [delegated NodeArray#push] module:GraphTheory.NodeArray#removeElement [remove edge] module:GraphTheory.Graph#removeEdge setEdges(eArr) clears and reassigns nodes to those of the edge array, and sets the edges functions basically as a graph reset, an easy way to explore a graph from different angles Parameters: Name Type Description eArr EdgeArray Source: graph_theory/graph_factory.js, line 176 See: [calls EdgeArray#getNodes] module:GraphTheory.EdgeArray#getNodes Returns: the modified graph Type Graph setNodes(nArr) clears the nodes and reassigns them to narr Parameters: Name Type Description nArr NodeArray Source: graph_theory/graph_factory.js, line 106 Returns: the current graph Type Graph shortestPath(initNode, termNode) composes the shortest path between two nodes by backtracing from dijkstra Parameters: Name Type Description initNode Node termNode Node Source: graph_theory/graph_factory.js, line 415 Returns: path of nodes Type Map subGraph(nArr) creates a new graph Parameters: Name Type Argument Description nArr NodeArray &lt;nullable&gt; a potential inital set of Nodes Source: graph_theory/graph_factory.js, line 198 Returns: a new Graph instance Type Graph subGraphByEdges( [eArr]) creates a new graph, and sets its edges, useful for exploring a graph based on different connections Parameters: Name Type Argument Default Description eArr EdgeArray &lt;optional&gt; this.edges a potential inital set of Edges Source: graph_theory/graph_factory.js, line 207 Returns: a new Graph instance Type Graph visitPath(pathArg) adds all unvisited nodes in the path to the specified component Parameters: Name Type Description pathArg Map the path to be explored Source: graph_theory/graph_factory.js, line 249 × Search results Close "},"module-GraphTheory.Node.html":{"id":"module-GraphTheory.Node.html","title":"Class: Node","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: Node GraphTheory. Node represent a Node new Node(label, data) Parameters: Name Type Description label String label property data Object the nodes data Source: graph_theory/node.js, line 9 Methods isEquivalent(newNode) Checks for identity via label attribute Parameters: Name Type Description newNode Node the node to be compared Source: graph_theory/node.js, line 41 Returns: Type Boolean setData(d) sets the node's data attribute Parameters: Name Type Description d Object Source: graph_theory/node.js, line 29 setLabel(lbl) sets the node's label attribute Parameters: Name Type Description lbl String Source: graph_theory/node.js, line 18 × Search results Close "},"module-GraphTheory.NodeArray.html":{"id":"module-GraphTheory.NodeArray.html","title":"Class: NodeArray","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: NodeArray GraphTheory. NodeArray represents a set of Nodes new NodeArray() Source: graph_theory/node_array_factory.js, line 19 Extends RobustArray × Search results Close "},"module-GraphTheory.RobustArray.html":{"id":"module-GraphTheory.RobustArray.html","title":"Class: RobustArray","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Class: RobustArray GraphTheory. RobustArray a type-specific array class implementing set theory new RobustArray() Source: graph_theory/robust_array_factory.js, line 15 Extends Array Methods RobustArray#clear(altArray) Parameters: Name Type Description altArray Object Source: graph_theory/robust_array_factory.js, line 152 Returns: the newly empty array Type RobustArray RobustArray#concat(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#concat arguments Source: graph_theory/robust_array_factory.js, line 84 Returns: Type RobustArray RobustArray#contains(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array_factory.js, line 41 Returns: Type Boolean RobustArray#copy() Source: graph_theory/robust_array_factory.js, line 161 Returns: a copy of this array Type RobustArray RobustArray#difference(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array_factory.js, line 201 Returns: the unshared elements Type RobustArray RobustArray#filter(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#filter arguments Source: graph_theory/robust_array_factory.js, line 64 Returns: Type RobustArray RobustArray#findEquivalentElement(altArray) Parameters: Name Type Description altArray Object Source: graph_theory/robust_array_factory.js, line 131 Returns: Type Object RobustArray#hasDistinctElements(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array_factory.js, line 191 Returns: does the caller have any element not included in the argument Type Boolean RobustArray#hasSameSize(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array_factory.js, line 103 Returns: do the arrays have the same length Type Boolean RobustArray#intersection(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array_factory.js, line 182 Returns: the shared elements Type RobustArray RobustArray#intersects(altArray) Parameters: Name Type Description altArray RobustArray the array to check Source: graph_theory/robust_array_factory.js, line 171 Returns: Type Boolean RobustArray#isEmpty() Source: graph_theory/robust_array_factory.js, line 31 Returns: is the array length 0 Type Boolean RobustArray#isEquivalent(altArray) Parameters: Name Type Description altArray Object Source: graph_theory/robust_array_factory.js, line 121 Returns: do the argument nad receiver share length and elements Type Boolean RobustArray#isSubset(altArray) Parameters: Name Type Description altArray Object Source: graph_theory/robust_array_factory.js, line 112 Returns: does the altArray contain every element of the receiver Type Boolean RobustArray#isValid(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array_factory.js, line 23 Returns: Type Boolean RobustArray#push(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array_factory.js, line 51 Returns: the current array Type RobustArray RobustArray#removeElement(argObj) Parameters: Name Type Description argObj Object Source: graph_theory/robust_array_factory.js, line 141 Returns: Type Object | Boolean RobustArray#slice(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#slice arguments Source: graph_theory/robust_array_factory.js, line 74 Returns: Type RobustArray RobustArray#splice(args) Parameters: Name Type Argument Description args Object &lt;repeatable&gt; JS Native Array#splice arguments Source: graph_theory/robust_array_factory.js, line 94 Returns: Type RobustArray RobustArray#union(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array_factory.js, line 211 Returns: Type RobustArray RobustArray#unionize(altArray) Parameters: Name Type Description altArray RobustArray Source: graph_theory/robust_array_factory.js, line 224 Returns: the receiver Type RobustArray &lt;inner&gt; ~RobustArray#excludeElement(exElem) Parameters: Name Type Description exElem Object the element to exclude Source: graph_theory/robust_array_factory.js, line 235 Returns: all of the elements in this object excluding exElem Type RobustArray × Search results Close "},"module-NodeArrayFactory.html":{"id":"module-NodeArrayFactory.html","title":"Module: NodeArrayFactory","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: NodeArrayFactory An NodeArrayFactory Source: graph_theory/node_array_factory.js, line 27 × Search results Close "},"module-RobustArrayFactory.html":{"id":"module-RobustArrayFactory.html","title":"Module: RobustArrayFactory","body":" DocStrap Modules EdgeArrayFactoryEdgeFactoryGraphFactoryGraphTheoryNodeArrayFactoryRobustArrayFactory Classes GraphTheory.ComponentArrayGraphTheory.DirectedEdgeGraphTheory.EdgeGraphTheory.EdgeArrayGraphTheory.GraphGraphTheory.NodeGraphTheory.NodeArrayGraphTheory.RobustArray Global Global Module: RobustArrayFactory A RobustArrayFactory Source: graph_theory/robust_array_factory.js, line 246 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
